import tkinter as tk
import customtkinter as ctk
import random
import sys
import threading
import time
import os
import winsound
import keyboard
import pyautogui
import requests
import uuid
from pynput.mouse import Listener, Button
from ctypes import *
from datetime import datetime

SERVER_URL = "https://login-server-suhj.onrender.com"

running = False
alive = True
right_mouse_pressed = False
search_color = 5197761
click_delay = 0.25

user = windll.LoadLibrary("user32.dll")
dc = user.GetDC(0)
gdi = windll.LoadLibrary("gdi32.dll")

def get_hwid():
    return str(uuid.getnode())

class Starfield:
    def __init__(self, canvas, width, height, num_stars=80):
        self.canvas = canvas
        self.width = width
        self.height = height
        self.stars = [
            {"x": random.randint(0, width), "y": random.randint(0, height),
             "size": random.randint(1, 3), "speed": random.uniform(0.5, 1.5)}
            for _ in range(num_stars)
        ]
        self.animate()

    def animate(self):
        self.canvas.delete("star")
        for star in self.stars:
            star["y"] += star["speed"]
            if star["y"] > self.height:
                star["y"] = 0
                star["x"] = random.randint(0, self.width)
            size = star["size"]
            self.canvas.create_oval(
                star["x"], star["y"], star["x"] + size, star["y"] + size,
                fill="hotpink", outline="", tags="star")
        self.canvas.after(30, self.animate)

ctk.set_appearance_mode("dark")
ctk.set_default_color_theme("dark-blue")

app = ctk.CTk()
app.title("Prime UI")
app.geometry("500x480")
app.resizable(False, False)

canvas = tk.Canvas(app, bg="#1e1e1e", highlightthickness=0)
canvas.place(relx=0, rely=0, relwidth=1, relheight=1)
starfield = Starfield(canvas, 500, 480)

tetris_frame = ctk.CTkFrame(app, fg_color="black")
tetris_frame.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)

tetris_canvas = tk.Canvas(tetris_frame, width=200, height=400, bg="black")
tetris_canvas.place(relx=0.5, rely=0.5, anchor="center")

GRID_WIDTH = 10
GRID_HEIGHT = 20
CELL_SIZE = 20

shapes = [
    [[1, 1, 1, 1]],  # I
    [[1, 1], [1, 1]],  # O
    [[0, 1, 0], [1, 1, 1]],  # T
    [[1, 0, 0], [1, 1, 1]],  # J
    [[0, 0, 1], [1, 1, 1]],  # L
    [[0, 1, 1], [1, 1, 0]],  # S
    [[1, 1, 0], [0, 1, 1]]   # Z
]

colors = ["cyan", "yellow", "purple", "blue", "orange", "green", "red"]

grid = [[None for _ in range(GRID_WIDTH)] for _ in range(GRID_HEIGHT)]
current_shape = None
current_color = None
current_x = 0
current_y = 0


def draw_block(x, y, color):
    tetris_canvas.create_rectangle(x * CELL_SIZE, y * CELL_SIZE,
                                   (x + 1) * CELL_SIZE, (y + 1) * CELL_SIZE,
                                   fill=color, outline="gray")

def draw_grid():
    tetris_canvas.delete("all")
    for y in range(GRID_HEIGHT):
        for x in range(GRID_WIDTH):
            if grid[y][x]:
                draw_block(x, y, grid[y][x])
    if current_shape:
        for y, row in enumerate(current_shape):
            for x, cell in enumerate(row):
                if cell:
                    draw_block(current_x + x, current_y + y, current_color)

def rotate(shape):
    return [list(row) for row in zip(*shape[::-1])]

def valid_position(shape, offset_x, offset_y):
    for y, row in enumerate(shape):
        for x, cell in enumerate(row):
            if cell:
                new_x = offset_x + x
                new_y = offset_y + y
                if new_x < 0 or new_x >= GRID_WIDTH or new_y >= GRID_HEIGHT:
                    return False
                if new_y >= 0 and grid[new_y][new_x]:
                    return False
    return True

def new_piece():
    global current_shape, current_color, current_x, current_y
    index = random.randint(0, len(shapes) - 1)
    current_shape = shapes[index]
    current_color = colors[index]
    current_x = GRID_WIDTH // 2 - len(current_shape[0]) // 2
    current_y = 0
    if not valid_position(current_shape, current_x, current_y):
        game_over()

def lock_piece():
    global current_shape
    for y, row in enumerate(current_shape):
        for x, cell in enumerate(row):
            if cell:
                grid[current_y + y][current_x + x] = current_color
    clear_lines()
    new_piece()

def clear_lines():
    global grid
    new_grid = [row for row in grid if any(cell is None for cell in row)]
    while len(new_grid) < GRID_HEIGHT:
        new_grid.insert(0, [None for _ in range(GRID_WIDTH)])
    grid = new_grid

def move(dx, dy):
    global current_x, current_y
    if valid_position(current_shape, current_x + dx, current_y + dy):
        current_x += dx
        current_y += dy
        draw_grid()
    elif dy == 1:
        lock_piece()

def drop():
    move(0, 1)
    tetris_canvas.after(500, drop)

def rotate_shape():
    global current_shape
    rotated = rotate(current_shape)
    if valid_position(rotated, current_x, current_y):
        current_shape = rotated
        draw_grid()

def game_over():
    tetris_canvas.create_text(100, 200, text="Game Over", fill="white", font=("Arial", 16))

def key(event):
    if event.keysym == "Left":
        move(-1, 0)
    elif event.keysym == "Right":
        move(1, 0)
    elif event.keysym == "Down":
        move(0, 1)
    elif event.keysym == "Up":
        rotate_shape()

app.bind("<Key>", key)
new_piece()
drop()

login_frame = ctk.CTkFrame(app, fg_color="transparent")
login_frame.place_forget()

ctk.CTkLabel(login_frame, text="Prime UI Login", font=("Consolas", 20)).pack(pady=10)
user_entry = ctk.CTkEntry(login_frame, placeholder_text="Username")
user_entry.pack(pady=5)
pass_entry = ctk.CTkEntry(login_frame, placeholder_text="Password", show="*")
pass_entry.pack(pady=5)
key_entry = ctk.CTkEntry(login_frame, placeholder_text="Key")
key_entry.pack(pady=5)
ctk.CTkButton(login_frame, text="Login", command=lambda: validate_login()).pack(pady=10)
error_label = ctk.CTkLabel(login_frame, text="")
error_label.pack()

main_frame = ctk.CTkFrame(app, fg_color="transparent")
main_frame.place_forget()

status_icon = ctk.CTkLabel(main_frame, text="ðŸ“¶", text_color="red", font=("Arial", 30))
status_icon.pack(pady=(40, 5))

status_label = ctk.CTkLabel(main_frame, text="Inactive", text_color="red", font=("Arial", 16))
status_label.pack(pady=(0, 30))

delay_label = ctk.CTkLabel(main_frame, text="VerzÃ¶gerung: 250 ms", font=("Arial", 14))
delay_label.pack(pady=(0, 5))

slider = ctk.CTkSlider(main_frame, from_=0, to=1000, command=lambda v: update_slider_label(v), button_color="#ff69b4")
slider.set(250)
slider.pack(pady=(0, 25))

start_button = ctk.CTkButton(main_frame, text="Start", fg_color="red", command=lambda: toggle_clicker(), width=150)
start_button.pack(pady=(0, 10))

kill_button = ctk.CTkButton(main_frame, text="Kill", fg_color="#b03060", command=lambda: kill_script(), width=150)
kill_button.pack()

made_by_label = ctk.CTkLabel(app, text="made by slix", text_color="hotpink", font=("Consolas", 10))
made_by_label.place(relx=1.0, y=5, anchor="ne")

def validate_login():
    data = {
        "username": user_entry.get(),
        "password": pass_entry.get(),
        "key": key_entry.get(),
        "hwid": get_hwid()
    }
    try:
        res = requests.post(SERVER_URL, json=data, timeout=10)
        response = res.json()
        if response.get("success"):
            login_frame.place_forget()
            main_frame.place(relx=0.5, rely=0.5, anchor="center")
        else:
            error_label.configure(text=response.get("message", "Login-Fehler"), text_color="red")
    except Exception as e:
        error_label.configure(text="Server nicht erreichbar", text_color="red")

def kill_script():
    global alive
    alive = False
    app.destroy()
    sys.exit()

def get_pixel():
    x = user.GetSystemMetrics(0) // 2
    y = user.GetSystemMetrics(1) // 2
    return gdi.GetPixel(dc, x, y)

def change_pixel_color():
    global search_color
    search_color = get_pixel()
    winsound.PlaySound("SystemAsterisk", winsound.SND_ALIAS)

def check():
    try:
        if get_pixel() == search_color:
            pyautogui.mouseDown()
            time.sleep(random.uniform(0.06, 0.2))
            pyautogui.mouseUp()
    except pyautogui.FailSafeException:
        pass

def on_click(x, y, button, pressed):
    global right_mouse_pressed
    if button == Button.right:
        right_mouse_pressed = pressed

mouse_listener = Listener(on_click=on_click)
mouse_listener.start()

def run_clicker():
    global alive, running
    while alive:
        if running and right_mouse_pressed:
            check()
        time.sleep(click_delay)

def toggle_clicker():
    global running
    running = not running
    status_label.configure(text="Active" if running else "Inactive", text_color="green" if running else "red")
    status_icon.configure(text_color="green" if running else "red")
    start_button.configure(text="Stop" if running else "Start", fg_color="green" if running else "red")

def update_slider_label(value):
    global click_delay
    click_delay = float(value) / 1000.0
    delay_label.configure(text=f"VerzÃ¶gerung: {int(float(value))} ms")

def check_hotkey():
    while True:
        if keyboard.is_pressed('ctrl') and keyboard.is_pressed('alt') and keyboard.is_pressed('7'):
            tetris_frame.place_forget()
            login_frame.place(relx=0.5, rely=0.5, anchor="center")
            break
        time.sleep(0.1)

threading.Thread(target=run_clicker, daemon=True).start()
threading.Thread(target=check_hotkey, daemon=True).start()

app.mainloop()
